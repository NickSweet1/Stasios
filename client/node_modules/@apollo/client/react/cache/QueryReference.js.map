{"version":3,"file":"QueryReference.js","sourceRoot":"","sources":["../../../src/react/cache/QueryReference.ts"],"names":[],"mappings":"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","sourcesContent":["import { equal } from \"@wry/equality\";\nimport type {\n  ApolloError,\n  ApolloQueryResult,\n  ObservableQuery,\n  OperationVariables,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { isNetworkRequestSettled } from \"../../core/index.js\";\nimport type { ObservableSubscription } from \"../../utilities/index.js\";\nimport {\n  createFulfilledPromise,\n  createRejectedPromise,\n} from \"../../utilities/index.js\";\nimport type { CacheKey } from \"./types.js\";\nimport type { useBackgroundQuery, useReadQuery } from \"../hooks/index.js\";\n\ntype Listener<TData> = (promise: Promise<ApolloQueryResult<TData>>) => void;\n\ntype FetchMoreOptions<TData> = Parameters<\n  ObservableQuery<TData>[\"fetchMore\"]\n>[0];\n\nconst QUERY_REFERENCE_SYMBOL: unique symbol = Symbol();\n/**\n * A `QueryReference` is an opaque object returned by {@link useBackgroundQuery}.\n * A child component reading the `QueryReference` via {@link useReadQuery} will\n * suspend until the promise resolves.\n */\nexport interface QueryReference<TData = unknown> {\n  [QUERY_REFERENCE_SYMBOL]: InternalQueryReference<TData>;\n}\n\ninterface InternalQueryReferenceOptions {\n  key: CacheKey;\n  onDispose?: () => void;\n  autoDisposeTimeoutMs?: number;\n}\n\nexport function wrapQueryRef<TData>(\n  internalQueryRef: InternalQueryReference<TData>\n): QueryReference<TData> {\n  return { [QUERY_REFERENCE_SYMBOL]: internalQueryRef };\n}\n\nexport function unwrapQueryRef<TData>(\n  queryRef: QueryReference<TData>\n): InternalQueryReference<TData> {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\n\nconst OBSERVED_CHANGED_OPTIONS = [\n  \"canonizeResults\",\n  \"context\",\n  \"errorPolicy\",\n  \"fetchPolicy\",\n  \"refetchWritePolicy\",\n  \"returnPartialData\",\n] as const;\n\ntype ObservedOptions = Pick<\n  WatchQueryOptions,\n  (typeof OBSERVED_CHANGED_OPTIONS)[number]\n>;\n\nexport class InternalQueryReference<TData = unknown> {\n  public result: ApolloQueryResult<TData>;\n  public readonly key: CacheKey;\n  public readonly observable: ObservableQuery<TData>;\n\n  public promiseCache?: Map<CacheKey, Promise<ApolloQueryResult<TData>>>;\n  public promise: Promise<ApolloQueryResult<TData>>;\n\n  private subscription: ObservableSubscription;\n  private listeners = new Set<Listener<TData>>();\n  private autoDisposeTimeoutId: NodeJS.Timeout;\n  private status: \"idle\" | \"loading\" = \"loading\";\n\n  private resolve: ((result: ApolloQueryResult<TData>) => void) | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private references = 0;\n\n  constructor(\n    observable: ObservableQuery<TData>,\n    options: InternalQueryReferenceOptions\n  ) {\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n    // Don't save this result as last result to prevent delivery of last result\n    // when first subscribing\n    this.result = observable.getCurrentResult(false);\n    this.key = options.key;\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    if (\n      isNetworkRequestSettled(this.result.networkStatus) ||\n      (this.result.data &&\n        (!this.result.partial || this.watchQueryOptions.returnPartialData))\n    ) {\n      this.promise = createFulfilledPromise(this.result);\n      this.status = \"idle\";\n    } else {\n      this.promise = new Promise((resolve, reject) => {\n        this.resolve = resolve;\n        this.reject = reject;\n      });\n    }\n\n    this.subscription = observable\n      .filter(({ data }) => !equal(data, {}))\n      .subscribe({\n        next: this.handleNext,\n        error: this.handleError,\n      });\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    this.autoDisposeTimeoutId = setTimeout(\n      this.dispose,\n      options.autoDisposeTimeoutMs ?? 30_000\n    );\n  }\n\n  get watchQueryOptions() {\n    return this.observable.options;\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      // Wait before fully disposing in case the app is running in strict mode.\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  didChangeOptions(watchQueryOptions: ObservedOptions) {\n    return OBSERVED_CHANGED_OPTIONS.some(\n      (option) =>\n        !equal(this.watchQueryOptions[option], watchQueryOptions[option])\n    );\n  }\n\n  applyOptions(watchQueryOptions: ObservedOptions) {\n    const {\n      fetchPolicy: currentFetchPolicy,\n      canonizeResults: currentCanonizeResults,\n    } = this.watchQueryOptions;\n\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (\n      currentFetchPolicy === \"standby\" &&\n      currentFetchPolicy !== watchQueryOptions.fetchPolicy\n    ) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.silentSetOptions(watchQueryOptions);\n\n      if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {\n        this.result = { ...this.result, ...this.observable.getCurrentResult() };\n        this.promise = createFulfilledPromise(this.result);\n      }\n    }\n\n    return this.promise;\n  }\n\n  listen(listener: Listener<TData>) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  refetch(variables: OperationVariables | undefined) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  }\n\n  fetchMore(options: FetchMoreOptions<TData>) {\n    return this.initiateFetch(this.observable.fetchMore<TData>(options));\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private handleNext(result: ApolloQueryResult<TData>) {\n    switch (this.status) {\n      case \"loading\": {\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n        this.status = \"idle\";\n        this.result = result;\n        this.resolve?.(result);\n        break;\n      }\n      case \"idle\": {\n        // This occurs when switching to a result that is fully cached when this\n        // class is instantiated. ObservableQuery will run reobserve when\n        // subscribing, which delivers a result from the cache.\n        if (result.data === this.result.data) {\n          return;\n        }\n\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n\n        this.result = result;\n        this.promise = createFulfilledPromise(result);\n        this.deliver(this.promise);\n        break;\n      }\n    }\n  }\n\n  private handleError(error: ApolloError) {\n    this.subscription.unsubscribe();\n    this.subscription = this.observable.resubscribeAfterError(\n      this.handleNext,\n      this.handleError\n    );\n\n    switch (this.status) {\n      case \"loading\": {\n        this.status = \"idle\";\n        this.reject?.(error);\n        break;\n      }\n      case \"idle\": {\n        this.promise = createRejectedPromise(error);\n        this.deliver(this.promise);\n      }\n    }\n  }\n\n  private deliver(promise: Promise<ApolloQueryResult<TData>>) {\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private initiateFetch(returnedPromise: Promise<ApolloQueryResult<TData>>) {\n    this.status = \"loading\";\n\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n\n    this.promise.catch(() => {});\n\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise\n      .then((result) => {\n        if (this.status === \"loading\") {\n          this.status = \"idle\";\n          this.result = result;\n          this.resolve?.(result);\n        }\n      })\n      .catch(() => {});\n\n    return returnedPromise;\n  }\n}\n"]}